http://www.is.cas.cn/xwdt2016/kjdt2016/201104/t20110418_3117726.html
 文章来源：  |  发布时间：2011-04-18  |  【打印】 【关闭】
为纪念Barry W. Boehm教授在计算机软件工程领域所作的突出贡献，中国科学院软件研究所(ISCAS)和《International Journal of Software and Informatics》(IJSI)决定主办Symposium in Honor of Prof. Barry W. Boehm，会议旨在纪念Boehm教授所取得的成就，表彰其在本领域所作突出贡献。会议将于2011年4月26日-27日在北京举行，将邀请十余位国外软件工程领域的杰出专家到现场做精彩的大会报告(预告附后)。我们真诚地邀请相关专业领域学者和专家参加会议。
1.　　　 Title: Empirical Software Engineering Models: Can they become the Equivalent of Physical Laws in Traditional Engineering?
Abstract: Traditional engineering disciplines such as mechanical and electrical engineering are guided by physical laws. They provide the constraints for acceptable engineering solutions by enforcing regularity and thereby limiting complexity. Violations of physical laws can be experienced instantly in the lab. Software engineering is not constrained by physical laws. Consequently, we often create software artifacts which are too complex to be understood, tested or maintained. As too complex software solutions may even work initially, we are tempted to believe that no laws apply. We only learn about the violation of some form of “cognitive laws” late during development or during maintenance, when too high complexity inflicts follow-up defects or increases maintenance costs. Initial work by Barry Boehm (e.g., CoCoMo) aimed at predicting and controlling software project costs based on estimated software size. Through innovative life cycle process models (e.g., Spiral model) Barry Boehm also provided the basis for incremental risk evaluation and adjustment of such predictions. The proposal in this paper is to work towards a scientific basis for software engineering by capturing more such time-lagging dependencies among software artifacts in the form of empirical models and thereby making developers aware of so-called “cognitive laws” that must be adhered to. This paper attempts to answer the questions why we need software engineering laws and how they could look like, how we have to organize our discipline in order to build up software engineering laws, what such laws already exist and how we could develop further laws, how such laws could contribute to the maturing of science and engineering of software in the future, and what the remaining challenges are for teaching, research, and practice in the future.
2.　　　 Title: Software Development Cost Modeling and Estimation Through a UNSW Lens 
Abstract: This paper investigates the manner in which Barry Boehm and his work have had an influence upon the research at UNSW into software development cost modeling and estimation. During the period 1979 to the present, faculty and students have investigated cost models for the commercial software development environment, project elapsed time compression, software sizing, estimation accuracy, and analysis of project history databases. This investigation reveals the foresight contained within the Boehm publications and the significant contribution made by these over the last three decades.
Abstract: Most organizations that depend on software are pursuing more flexible architectures and more agile life-cycle processes to increase business flexibility. What does agility look like, and how do we measure it? A truly agile project or organization should experience changes that are more straightforward and more predictable. Consequently, improvements are best measured by gauging the change trends in software baselines. A well-accepted tenet of software engineering states, “The later you are in the life cycle, the more expensive things are to fix.” This iron law, an artifact of a waterfall culture, should not apply if you have transformed to agile software delivery with a well-architected system. This bold assertion is the root of the metric patterns presented in this paper. 
Abstract: Clients of reactive systems often change their priorities. For example, a human user of an email viewer may attempt to display a new message while a large attachment is already downloading. To the user, an email viewer that delayed display of the message would exhibit a failure analogous to priority inversion in real-time systems. We propose a new quality attribute, {\it attentiveness}, intended to provide a unified way to model the forms of redirection offered by application-level reactive systems to accommodate the changing priorities of their clients. Modeling attentiveness as a quality attribute provides systems designers with a single modeling framework for policy and architectural decisions to address trade-offs among criteria such as responsiveness, overall performance, behavioral predictability, and state consistency. Clients of the reactive system could be human users or system components. This latter possibility suggests that the modeling framework must support an appropriate kind of composability, which would enable it to support architectural design of attentive systems at scale.
At the policy level, the framework models a diverse set of familiar redirection options including cancel, undo, defer, suspend/preempt, and ignore. At the architectural level, the framework includes a suite of concepts to support the design of attentive systems and the refactoring of existing systems to enhance attentiveness. These concepts include: (1) Distinguishing “short'” operations (such as an event notification) from “long” operations (such as an unbounded data transfer over a network). (2) Technical means to encapsulate long operations to prevent interference with redirection. (3) Technical means to enable use of light-weight checkpoints to support redirection while executing “long” operations. (4) Consolidation of responsibility for redirection to a relatively small group of components in the system. Policy and architecture come together in the form of a set of positive and negative patterns for realizing attentive systems. These patterns are derived from case studies of attentiveness failures and successes.
This paper summarizes the key concepts of attentiveness, including modeling and architecture. The concepts are assessed against a variety of case studies, including refactoring experiments and new development projects involving both human-system interaction (in a document editor) and system-system interaction (in a client-server application). A principal goal is to develop a modeling framework and set of associated practices that can guide incremental improvements in enhancing the attentiveness of both existing and new reactive systems.
5.　　　 Title: Environment Support for Improving Software Development Processes: A Vision Influenced by the Work of Barry W. Boehm
Abstract: Throughout his career, Barry Boehm has advocated the importance of understanding software development processes, measuring their performance, and using those measurements to guide the development of improved process models. In this paper, we describe PIE, a Process Improvement Environment, which supports that vision. PIE supports the definition of process models that can be analyzed and executed. The analysis is used to detect errors and vulnerabilities in the process models. Validated process models can then be simulated to detect inefficiencies and bottlenecks. Future work includes executing these process models, monitoring their performance, and then using that information to drive further process improvements.
6.　　　 Title: Organizing Projects Around the Mitigation of Risks Arising from System Dynamic Behavior
Abstract: Many of the key products and services used by modern societies are the result of large-scale engineering projects. Despite decades of theoretical and practical work in the art of systems engineering and project management, project execution results remain somewhat inconsistent, in the sense that many projects fail to produce a product that meets the original specifications, and many more projects achieve some measure of technical success only after taking significantly more time and/or money than originally expected. One source of such failures is the occurrence of unplanned and adverse dynamic behavior in the resulting system. This paper summarizes research being conducted to look at the potential of design-phase actions that centralize control of the eventual system’s dynamic behavior as a potential solution to some instances of this problem. This approach could lead to increased chances of success on future major system development projects, through a new method for instituting better control of the dynamic behavior of such a system.
7.　　　 Title: Polyphonic Aspects of Software Process: Looking for Philosophical Foundation of Software Engineering
Abstract: This retrospective essay summarizes 50 years experience of a first-generation programmer in Japan focusing on his thoughts on software process issues. It started from strong concern of the structure of program execution processes inside computer hardware, then went out of digital box to think about software development and maintenance processes, namely how to deal with issues between people and software. Finally his main concern turned to the social issues of software evolution processes in the Internet society. The concept of “immaterial labor” seems to be important to think about today's process issues outside of digital boxes.
8.　　　 Title: A Process Programmer Looks at the Spiral Model: A Tribute To the Deep Insights of Barry W. Boehm
Abstract: This paper elaborates on implications of Barry W. Boehm's Spiral Model of software development. The paper notes that the Spiral Model presents a compelling view of software development, evocatively represented by a visual image that appeals strongly to intuition, and notes that the view and image have motivated and justified a range of important views of how software development should be done. This paper enhances and elaborates on the intuitions by supplementing them with a definition of the Spiral Model that is enunciated in terms of a rigorously defined language. The rigorous enunciation and accompanying alternative visual depiction are then used to provide clarification and formalization of some of the clearly-indicated elaborations of the Spiral Model. Both the Waterfall Model of software development and the Scrum agile method are presented as possible elaborations of the Spiral Model. Still other elaborations are indicated. Similarities in the visualizations of these development approaches suggest some underlying similarities in the approaches themselves, suggesting the potential value of effective process visualizations. The breadth of these elaborations is also used to suggest how the Spiral Model seems to provide a strong focus on some of the quintessential aspects of what comprises effective software development.
Abstract: Boehm is credited to have formulated the “Two Rights” of software: the problem of getting the right software and the problem of getting the software right. The development processes needed to achieve software that is right, to us, requires that a proper study of the application domain be done before a serious requirements study is attempted; and to achieve the right software, that is, software that is correct, to us, requires that a proper engineering degree of formalism be applied to the entire development process; that is, that we re-interpret classical development processes. We shall in this paper focus only on the issue of obtaining the right software. In this paper talk we shall outline what we mean by a proper study of the application domain and how it influences the requirements development.
10.　 Title: The Influence of Prof. Barry Boehm’s Legacy on Indian Software Industry: Infosys Perspective
Abstract: Friends, I am indeed delighted to be here with all of you, on this day, at this symposium in honor of Prof. Barry W. Boehm on his 75th birth day. First of all I want to congratulate and commend the organizing team for having conceptualized a wonderful event like this in honor of an extraordinary researcher who has significantly advanced almost every area of software engineering. I want to thank them for inviting me here and for giving me an opportunity to pay tribute to an outstanding practitioner-academician whom I admire deeply, whose contributions to the field have benefited tremendously many organizations engaged in the field of software engineering, like my own company Infosys. Thank you very much indeed…
