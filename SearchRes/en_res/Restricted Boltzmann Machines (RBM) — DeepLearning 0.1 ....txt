This section assumes the reader has already read through Classifying MNIST digits using Logistic Regression
and concepts: T.tanh, shared variables, basic arithmetic ops, T.grad, Random numbers, floatX and scan. If you intend to run the code on GPU also read GPU.
Energy-based models associate a scalar energy to each configuration of the
so that its shape has desirable properties. For example, we would like
descent on the empirical negative log-likelihood of the training data. As for
the logistic regression we will first define the log-likelihood and then the
using the stochastic gradient , where are the parameters of the model.
In many cases of interest, we do not observe the example fully, or we
want to introduce some non-observed variables to increase the expressive power
of the model. So we consider an observed part (still denoted here) and a
In such cases, to map this formulation to one similar to Eq. (1), we
introduce the notation (inspired from physics) of free energy, defined as
Notice that the above gradient contains two terms, which are referred to as
the positive and negative phase. The terms positive and negative do
not refer to the sign of each term in the equation, but rather reflect their
effect on the probability density defined by the model. The first term
increases the probability of training data (by reducing the corresponding free
energy), while the second term decreases the probability of samples generated
It is usually difficult to determine this gradient analytically, as it
nothing less than an expectation over all possible configurations of the input
The first step in making this computation tractable is to estimate the
expectation using a fixed number of model samples. Samples used to estimate the
negative phase gradient are referred to as negative particles, which are
With the above formula, we almost have a pratical, stochastic algorithm for
learning an EBM. The only missing ingredient is how to extract these negative
sampling methods, Markov Chain Monte Carlo methods are especially well suited
for models such as the Restricted Boltzmann Machines (RBM), a specific type of
Boltzmann Machines (BMs) are a particular form of log-linear Markov Random Field (MRF),
i.e., for which the energy function is linear in its free parameters. To make
them powerful enough to represent complicated distributions (i.e., go from the
limited parametric setting to a non-parametric one), we consider that some of
the variables are never observed (they are called hidden). By having more hidden
variables (also called hidden units), we can increase the modeling capacity
Because of the specific structure of RBMs, visible and hidden units are
In the commonly studied case of using binary units (where and ), we obtain from Eq. (6) and (2), a probabilistic
The free energy of an RBM with binary units further simplifies to:
For a more detailed derivation of these equations, we refer the reader to the
or to section 5 of Learning Deep Architectures for AI. We will however not use these formulas, but rather get the gradient using Theano T.grad
Samples of can be obtained by running a Markov chain to
is done through a sequence of N sampling sub-steps of the form
For RBMs, consists of the set of visible and hidden units. However,
fixed values of the hidden units. Similarly, hidden units are sampled
simultaneously given the visibles. A step in the Markov chain is thus taken as
where refers to the set of all hidden units at the n-th step of
the Markov chain. What it means is that, for example, is
In theory, each parameter update in the learning process would require running
one such chain to convergence. It is needless to say that doing so would be
Contrastive Divergence uses two tricks to speed up the sampling process:
distribution of the data), we initialize the Markov chain with a training
example (i.e., from a distribution that is expected to be close to ,
so that the chain will be already close to having converged to its final distribution ).
CD does not wait for the chain to converge. Samples are obtained after only
k-steps of Gibbs sampling. In pratice, has been shown to work
. It relies on a single Markov chain, which has a persistent
state (i.e., not restarting a chain for each observed example). For each
parameter update, we extract new samples by simply running the chain for
k-steps. The state of the chain is then preserved for subsequent updates.
The general intuition is that if parameter updates are small enough compared
to the mixing rate of the chain, the Markov chain should be able to catch up
We construct an RBM class. The parameters of the network can either be
initialized by the constructor or can be passed as arguments. This option is
useful when an RBM is used as the building block of a deep network, in which
case the weight matrix and the hidden layer bias is shared with the
 RBM constructor. Defines the parameters of the model along with
 :param input: None for standalone RBMs or symbolic variable if RBM is
 :param W: None for standalone RBMs or symbolic variable pointing to a
 shared weight matrix in case RBM is part of a DBN network; in a DBN,
 the weights are shared between RBMs and layers of a MLP
 :param hbias: None for standalone RBMs or symbolic variable pointing
 to a shared hidden units bias vector in case RBM is part of a
 :param vbias: None for standalone RBMs or a symbolic variable
 # initialize input layer for standalone RBM or layer0 of DBN
 # **** WARNING: It is not a good idea to put things in this list
Next step is to define functions which construct the symbolic graph associated
 Note that we return also the pre-sigmoid activation of the
 layer. As it will turn out later, due to how Theano deals with
 down a more stable computational graph (see details in the
  This function infers state of hidden units given visible units 
 # compute the activation of the hidden units given a sample of
 # get a sample of the hiddens given their activation
 # Note that theano_rng.binomial returns a symbolic sample of dtype
 # int64 by default. If we want to keep our computations in floatX
 # for the GPU we need to specify to return the dtype floatX
 layer. As it will turn out later, due to how Theano deals with
 down a more stable computational graph (see details in the
  This function infers state of visible units given hidden units 
 # compute the activation of the visible given the hidden sample
 # get a sample of the visible given their activation
 # Note that theano_rng.binomial returns a symbolic sample of dtype
 # int64 by default. If we want to keep our computations in floatX
 # for the GPU we need to specify to return the dtype floatX
We can then use these functions to define the symbolic graph for a Gibbs
gibbs_vhv which performs a step of Gibbs sampling starting from the
visible units. As we shall see, this will be useful for sampling from the
gibbs_hvh which performs a step of Gibbs sampling starting from the hidden units.
This function will be useful for performing CD and PCD updates.
activation. To understand why this is so you need to understand a bit about
how Theano works. Whenever you compile a Theano function, the computational
graph that you pass as input gets optimized for speed and stability. This
is done by changing several parts of the subgraphs with others. One
such optimization expresses terms of the form log(sigmoid(x)) in terms of
softplus. We need this optimization for the cross-entropy since sigmoid of
numbers larger than 30. (or even less then that) turn to 1. and numbers
smaller than -30. turn to 0 which in terms will force theano
to compute log(0) and therefore we will get either -inf or NaN
as cost. If the value is expressed in terms of softplus we do
fine, but here we have a special case. The sigmoid is applied inside
the scan op, while the log is outside. Therefore Theano will only
the wanted optimization. We can not go and replace the sigmoid
in scan with something else also, because this only needs to be
done on the last step. Therefore the easiest and more efficient way
is to get also the pre-sigmoid activation as an output of scan,
and apply both the log and sigmoid outside scan such that Theano
The class also has a function that computes the free energy of the model,
We then add a get_cost_updates method, whose purpose is to generate the symbolic
 containing old state of Gibbs chain. This must be a shared
 :param k: number of Gibbs steps to do in CD-k/PCD-k
 Returns a proxy for the cost and the updates dictionary. The
 dictionary contains the update rules for weights and biases but
 also an update of the shared variable used to store the persistent
 # for CD, we use the newly generate hidden sample
 # for PCD, we initialize from the old state of the chain
Note that get_cost_updates takes as argument a variable called persistent. This allows us to use the same code to implement both CD and PCD.
To use PCD, persistent should refer to a shared variable which contains the
If persistent is None, we initialize the Gibbs chain with the hidden
sample generated during the positive phase, therefore implementing CD. Once we have established the
starting point of the chain, we can then compute the sample at the end of the
Gibbs chain, sample that we need for getting the gradient (see Eq. (4)). To do so, we will use the scan
op provided by Theano, therefore we urge the reader to look it up by following this link.
 # in order to implement CD-k/PCD-k we need to scan over the
 # Read Theano tutorial on scan for more information :
Once we have the generated the chain we take the sample at the end of the
chain to get the free energy of the negative phase. Note that the
chain_end is a symbolical Theano variable expressed in terms of the model
parameters, and if we would apply T.grad naively, the function will
try to go through the Gibbs chain to get the gradients. This is not what we
want (it will mess up our gradients) and therefore we need to indicate to
T.grad that chain_end is a constant. We do this by using the argument
 # note that we only need the sample at the end of the chain
 # We must not compute the gradient through the gibbs sampling
Finally, we add to the updates dictionary returned by scan (which contains
updates rules for random states of theano_rng) to contain the parameter
updates. In the case of PCD, these should also update the shared variable
 # make sure that the learning rate is of the right dtype
 # Note that this works only if persistent is a shared variable
progresses, we know that the model defined by the RBM becomes closer to the
look like samples from the training set. Obviously bad hyperparameters can be
The filters learnt by the model can be visualized. This amounts to plotting
the weights of each unit as a gray-scale image (after reshaping to a square
matrix). Filters should pick out strong features in the data. While it is not
clear for an arbitrary dataset, what these features should look like, training
on MNIST usually results in filters which act as stroke detectors, while
training on natural images lead to Gabor like filters if trained in
Other, more tractable functions can be used as a proxy to the likelihood. When
training an RBM with PCD, one can use pseudo-likelihood as the proxy.
Pseudo-likelihood (PL) is much less expensive to compute, as it assumes that
. The log-PL is therefore the sum of the log-probabilities of each
bit , conditioned on the state of all other bits. For MNIST, this
would involve summing over the 784 input dimensions, which remains rather
expensive. For this reason, we use the following stochastic approximation to
where the expectation is taken over the uniform random choice of index ,
and is the number of visible units. In order to work with binary
 with bit-i being flipped (1->0, 0->1). The log-PL for an RBM with binary units is
We therefore return this cost as well as the RBM updates in the get_cost_updates function of the RBM class.
index of bit . This will result in bit cycling over all possible
Note that for CD training the cross-entropy cost between the input and the
reconstruction (the same as the one used for the de-noising autoencoder) is more reliable then the pseudo-loglikelihood. Here is the code we use to
 # index of bit i in expression p(x_i | x_{\i})
 # binarize the input image by rounding to nearest integer
 # flip bit x_i of matrix xi and preserve all other bits x_{\i}
 # the result to xi_flip, instead of working in place on xi.
We now have all the necessary ingredients to start training our network.
Before going over the training loop however, the reader should familiarize
himself with the function tile_raster_images (see Plotting Samples and Filters). Since
RBMs are generative models, we are interested in sampling from them and
(weights) learnt by the RBM, to gain insights into what the RBM is actually
doing. Bear in mind however, that this does not provide the entire story,
since we neglect the biases and plot the weights up to a multiplicative
Having these utility functions, we can start training the RBM and plot/save
the filters after each training epoch. We train the RBM using PCD, as it has
 # it is ok for a theano function to have no output
 # the purpose of train_rbm is solely to update the RBM parameters
Once the RBM is trained, we can then use the gibbs_vhv function to implement
the Gibbs chain required for sampling. We initialize the Gibbs chain starting
from test examples (although we could as well pick it from the training set)
in order to speed up convergence and avoid problems with random
initialization. We again use Theanos scan op to do 1000 steps before
 # pick random test examples, with which to initialize the persistent chain
Next we create the 20 persistent chains in parallel to get our
samples. To do so, we compile a theano function which performs one Gibbs step
and updates the state of the persistent chain with the new visible sample. We
apply this function iteratively for a large number of steps, plotting the
 # define one step of Gibbs sampling (mf = mean-field) define a
 # add to updates the shared variable that takes care of our persistent
 # we generate the "mean field" activations for plotting and the actual
 # samples for reinitializing the state of our persistent chain
 # create a space to store the image for plotting ( we need to leave
 (29 * n_samples + 1, 29 * n_chains - 1),
 # because successive samples in the chain are too correlated
 image_data[29 * idx:29 * idx + 28, :] = tile_raster_images(
We ran the code with PCD-15, learning rate of 0.1 and a batch size of 20, for
15 epochs. Training the model takes 122.466 minutes on a Intel Xeon E5430 
Here are the samples generated by the RBM after training. Each row
chains). 1000 steps of Gibbs sampling were taken between each of those rows.
