[pdf] Grégoire Mesnil, Xiaodong He, Li Deng and Yoshua Bengio. Investigation of Recurrent-Neural-Network Architectures and Learning Methods for Spoken Language Understanding. Interspeech, 2013.
[pdf] Gokhan Tur, Dilek Hakkani-Tur and Larry Heck. What is left to be understood in ATIS?
[pdf] Christian Raymond and Giuseppe Riccardi. Generative and discriminative algorithms for spoken language understanding. Interspeech, 2007.
[pdf] Bastien, Frédéric, Lamblin, Pascal, Pascanu, Razvan, Bergstra, James, Goodfellow, Ian, Bergeron, Arnaud, Bouchard, Nicolas, and Bengio, Yoshua. Theano: new features and speed improvements. NIPS Workshop on Deep Learning and Unsupervised Feature Learning, 2012.
[pdf] Bergstra, James, Breuleux, Olivier, Bastien, Frédéric, Lamblin, Pascal, Pascanu, Razvan, Desjardins, Guillaume, Turian, Joseph, Warde-Farley, David, and Bengio, Yoshua. Theano: a CPU and GPU math expression compiler. In Proceedings of the Python for Scientific Computing Conference (SciPy), June 2010.
for any problem report or feedback. We will be glad to hear from you.
An old and small benchmark for this task is the ATIS (Airline Travel Information
System) dataset collected by DARPA. Here is a sentence (or utterance) example using the
The ATIS offical split contains 4,978/893 sentences for a total of 56,590/9,198
words (average sentence length is 15) in the train/test set. The number of
we deal with unseen words in the test set by marking any words with only one
single occurrence in the training set as <UNK> and use this token to
represent those unseen words in the test set. As Ronan Collobert and colleagues, we converted
sequences of numbers with the string DIGIT i.e. 1984 is converted to
We split the official train set into a training and validation set that contain
performance improvement difference has to be greater than 0.6% in F1 measure at
the 95% level due to the small size of the dataset.
A token corresponds to a word. Each token in the ATIS vocabulary is associated to an index. Each sentence is a
array of indexes (int32). Then, each set (train, valid, test) is a list of arrays of indexes. A python
dictionary is defined for mapping the space of indexes to the space of words.
array([126, 126, 126, 126, 126, 48, 50, 126, 78, 123, 81, 126, 15,
Given a sentence i.e. an array of indexes, and a window size i.e. 1,3,5,..., we
need to convert each word in the sentence to a context window surrounding this
 win :: int corresponding to the size of the window
 it will return a list of list of indexes corresponding
 lpadded = win // 2 * [-1] + l + win // 2 * [-1]
The index -1 corresponds to the PADDING index we insert at the
To summarize, we started with an array of indexes and ended with a matrix of
indexes. Each line corresponds to the context window surrounding this word.
Once we have the sentence converted to context windows i.e. a matrix of indexes, we have to associate
these indexes to the embeddings (real-valued vector associated to each word).
 (nv+1, de)).astype(theano.config.floatX)) # add one for PADDING at the end
idxs = T.imatrix() # as many columns as words in the context window and as many lines as words in the sentence
The x symbolic variable corresponds to a matrix of shape (number of words in the
We now have a sequence (of length 5 which is corresponds to the length of the
sentence) of context window word embeddings which is easy to feed to a simple
The followin (Elman) recurrent neural network (E-RNN) takes as input the current input
(time t) and the previous hiddent state (time t-1). Then it iterates.
In the previous section, we processed the input to fit this
sequential/temporal structure. It consists in a matrix where the row 0 corresponds to
the time step t=0, the row 1 corresponds to the time step t=1, etc.
two matrices for the linear projection of the input t and the previous hidden layer state t-1
Then we integrate the way to build the input from the embedding matrix:
We use the scan operator to construct the recursion, works like a charm:
Theano will then compute all the gradients automatically to maximize the log-likelihood:
We keep the word embeddings on the unit sphere by normalizing them after each update:
With the previous defined functions, you can compare the predicted labels with
the true labels and compute some metrics. In this repo, we build a wrapper around the conlleval PERL script.
Its not trivial to compute those metrics due to the Inside Outside Beginning
i.e. a prediction is considered correct if the word-beginning and the
Note that the extension is and you will have to change it to .
For stochastic gradient descent (SGD) update, we consider the whole sentence as a mini-batch
and perform one update per sentence. It is possible to perform a pure SGD (contrary to mini-batch)
where the update is done on only one single word at a time.
After each iteration/update, we normalize the word embeddings to keep them on a unit sphere.
the training is run for a given number of epochs (a single pass through the
whole dataset) and keep the best model along with respect to the F1 score
will run one epoch in less than 40 seconds on i7 CPU 950  3.07GHz using less than 200 Mo of RAM:
After a few epochs, you obtain decent performance 94.48 % of F1 score.:
NEW BEST: epoch 28 valid F1 96.61 best test F1 94.19
NEW BEST: epoch 29 valid F1 96.63 best test F1 94.42
NEW BEST: epoch 40 valid F1 97.25 best test F1 94.34
NEW BEST: epoch 42 valid F1 97.33 best test F1 94.48
