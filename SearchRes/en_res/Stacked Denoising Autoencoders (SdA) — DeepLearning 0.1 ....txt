This section assumes you have already read through Classifying MNIST digits using Logistic Regression
and concepts: T.tanh, shared variables, basic arithmetic ops, T.grad, Random numbers, floatX. If you intend to run the code on GPU also read GPU.
The Stacked Denoising Autoencoder (SdA) is an extension of the stacked
Especially if you do not have experience with autoencoders, we recommend reading it
Denoising autoencoders can be stacked to form a deep network by
below as input to the current layer. The unsupervised pre-training of such an
architecture is done one layer at a time. Each layer is trained as
a denoising autoencoder by minimizing the error in reconstructing its input
are trained, we can train the -th layer because we can now
Once all layers are pre-trained, the network goes through a second stage
where we want to minimize prediction error on a supervised task.
layer on top of the network (more precisely on the output code of the
perceptron. At this point, we only consider the encoding parts of
This stage is supervised, since now we use the target class during
training. (See the Multilayer Perceptron for details on the multilayer perceptron.)
This can be easily implemented in Theano, using the class defined
previously for a denoising autoencoder. We can see the stacked denoising
autoencoders, and an MLP. During pre-training we use the first facade, i.e., we treat our model
as a list of autoencoders, and train each autoencoder seperately. In the
second stage of training, we use the second facade. These two facades are linked because:
the autoencoders and the sigmoid layers of the MLP share parameters, and
the latent representations computed by intermediate layers of the MLP are fed as input to the autoencoders.
 A stacked denoising autoencoder model is obtained by stacking several
 dAs. The hidden layer of the dA at layer `i` becomes the input of
 the dA at layer `i+1`. The first layer dA gets as input the input of
 the SdA, and the hidden layer of the last dA represents the output.
 Note that after pretraining, the SdA is dealt with as a normal MLP,
 """ This class is made to support a variable number of layers.
 :param numpy_rng: numpy random number generator used to draw initial
 :param theano_rng: Theano random generator; if None is given one is
 self.x = T.matrix(x) # the data is presented as rasterized images
 self.y = T.ivector(y) # the labels are presented as 1D vector of
self.sigmoid_layers will store the sigmoid layers of the MLP facade, while
self.dA_layers will store the denoising autoencoder associated with the layers of the MLP.
autoencoders, where n_layers is the depth of our model. We use the
We link the sigmoid layers to form an MLP, and construct
the denoising autoencoders such that each shares the weight matrix and the
 # the size of the input is either the number of hidden units of
 # the layer below or the input size if we are on the first layer
 # the input to this layer is either the activation of the hidden
 # layer below or the input of the SdA if you are on the first
 # but we are going to only declare that the parameters of the
 # the visible biases in the dA are parameters of those
 # Construct a denoising autoencoder that shared weights with this
All we need now is to add a logistic layer on top of the sigmoid
use the LogisticRegression class introduced in Classifying MNIST digits using Logistic Regression.
 # We now need to add a logistic layer on top of the MLP
 # construct a function that implements one step of finetunining
 # compute the gradients with respect to the model parameters
 # symbolic variable that points to the number of errors made on the
  Generates a list of functions, each of them implementing one
 step in trainnig the dA corresponding to the layer with same index.
 The function will require as input the minibatch index, and to train
 a dA you just need to iterate, calling the corresponding function on
 :param learning_rate: learning rate used during training for any of
To be able to change the corruption level or the learning rate
learning rate. Note that the names of the parameters are the names given
to the Theano variables when they are constructed, not the names of the
In the same fashion we build a method for constructing the functions required
 a batch from the validation set, and a function `test` that
 computes the error on a batch from the testing set
 :param datasets: It is a list that contain all the datasets;
 # compute number of minibatches for training, validation and testing
 # compute the gradients with respect to the model parameters
 # Create a function that scans the entire validation set
 # Create a function that scans the entire test set
validation set and the entire test set, respectively, producing a list of the losses
There are two stages of training for this network: layer-wise pre-training
For the pre-training stage, we will loop over all the layers of the
network. For each layer we will use the compiled Theano function that
the reconstruction cost of that layer. This function will be applied
to the training set for a fixed number of epochs given by
 print(Pre-training layer %i, epoch %d, cost %f % (i, epoch, numpy.mean(c, dtype=float64)))
  ran for %.2fm % ((end_time - start_time) / 60.)), file=sys.stderr)
The fine-tuning loop is very similar to the one in the Multilayer Perceptron. The
By default the code runs 15 pre-training epochs for each layer, with a batch
size of 1. The corruption levels are 0.1 for the first layer, 0.2 for the second,
and 0.3 for the third. The pretraining learning rate is 0.001 and
the finetuning learning rate is 0.1. Pre-training takes 585.01 minutes, with
an average of 13 minutes per epoch. Fine-tuning is completed after 36 epochs
in 444.2 minutes, with an average of 12.34 minutes per epoch. The final
One way to improve the running time of your code (assuming you have
sufficient memory available), is to compute how the network, up to layer
, transforms your data. Namely, you start by training your first
layer dA. Once it is trained, you can compute the hidden units values for
every datapoint in your dataset and store this as a new dataset that you will
use to train the dA corresponding to layer 2. Once you have trained the dA for
layer 2, you compute, in a similar fashion, the dataset for layer 3 and so on.
You can see now, that at this point, the dAs are trained individually, and
they just provide (one to the other) a non-linear transformation of the input.
Once all dAs are trained, you can start fine-tuning the model.
