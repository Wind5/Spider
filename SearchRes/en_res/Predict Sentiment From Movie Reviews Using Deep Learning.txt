Sentiment analysis is a natural language processing problem where text is understood and the underlying intent is predicted.
In this post, you will discover how you can predict the sentiment of movie reviews as either positive or negative in Python using the Keras deep learning library.
About the IMDB sentiment analysis problem for natural language processing and how to load it in Keras.
How to use word embedding in Keras for natural language problems.
How to develop and evaluate a multi-layer perception model for the IMDB problem.
How to develop a one-dimensional convolutional neural network model for the IMDB problem.
Update Mar/2017: Updated example for Keras 2.0.2, TensorFlow 1.0.1 and Theano 0.9.0.
Predict Sentiment From Movie Reviews Using Deep LearningPhoto by SparkCBC, some rights reserved.
The dataset is the Large Movie Review Dataset often referred to as the IMDB dataset.
The Large Movie Review Dataset (often referred to as the IMDB dataset) contains 25,000 highly polar moving reviews (good or bad) for training and the same amount again for testing. The problem is to determine whether a given moving review has a positive or negative sentiment.
The data was collected by Stanford researchers and was used in a 2011 paper [PDF] where a split of 50/50 of the data was used for training and test. An accuracy of 88.89% was achieved.
The data was also used as the basis for a Kaggle competition titled Bag of Words Meets Bags of Popcorn in late 2014 to early 2015. Accuracy was achieved above 97% with winners achieving 99%.
Take my free 2-week email course and discover MLPs, CNNs and LSTMs (with sample code).
Click to sign-up now and also get a free PDF Ebook version of the course.
The keras.datasets.imdb.load_data() allows you to load the dataset in a format that is ready for use in neural network and deep learning models.
The words have been replaced by integers that indicate the absolute popularity of the word in the dataset. The sentences in each review are therefore comprised of a sequence of integers.
Calling imdb.load_data() the first time will download the IMDB dataset to your computer and store it in your home directory under ~/.keras/datasets/imdb.pkl as a 32 megabyte file.
Usefully, the imdb.load_data() provides additional arguments including the number of top words to load (where words with a lower integer are marked as zero in the returned data), the number of top words to skip (to avoid the thes) and the maximum length of reviews to support.
Lets load the dataset and calculate some properties of it. We will start off by loading some libraries and loading the entire IMDB dataset as a training dataset.
import numpyfrom keras.datasets import imdbfrom matplotlib import pyplot# load the dataset(X_train, y_train), (X_test, y_test) = imdb.load_data()X = numpy.concatenate((X_train, X_test), axis=0)y = numpy.concatenate((y_train, y_test), axis=0)
# Summarize review lengthprint("Review length: ")result = [len(x) for x in X]print("Mean %.2f words (%f)" % (numpy.mean(result), numpy.std(result)))# plot review lengthpyplot.boxplot(result)pyplot.show()
Looking a box and whisker plot for the review lengths in words, we can probably see an exponential distribution that we can probably cover the mass of the distribution with a clipped length of 400 to 500 words.
A recent breakthrough in the field of natural language processing is called word embedding.
This is a technique where words are encoded as real-valued vectors in a high-dimensional space, where the similarity between words in terms of meaning translates to closeness in the vector space.
Discrete words are mapped to vectors of continuous numbers. This is useful when working with natural language problems with neural networks and deep learning models are we require numbers as input.
Keras provides a convenient way to convert positive integer representations of words into a word embedding by an Embedding layer.
The layer takes arguments that define the mapping including the maximum number of expected words also called the vocabulary size (e.g. the largest integer value that will be seen as an integer). The layer also allows you to specify the dimensionality for each word vector, called the output dimension.
We would like to use a word embedding representation for the IMDB dataset.
Lets say that we are only interested in the first 5,000 most used words in the dataset. Therefore our vocabulary size will be 5,000. We can choose to use a 32-dimension vector to represent each word. Finally, we may choose to cap the maximum review length at 500 words, truncating reviews longer than that and padding reviews shorter than that with 0 values.
The output of this first layer would be a matrix with the size 32500 for a given review training or test pattern in integer format.
Now that we know how to load the IMDB dataset in Keras and how to use a word embedding representation for it, lets develop and evaluate some models.
We can start off by developing a simple multi-layer perceptron model with a single hidden layer.
The word embedding representation is a true innovation and we will demonstrate what would have been considered world class results in 2011 with a relatively simple neural network.
Lets start off by importing the classes and functions required for this model and initializing the random number generator to a constant value to ensure we can easily reproduce the results.
# MLP for the IMDB problemimport numpyfrom keras.datasets import imdbfrom keras.models import Sequentialfrom keras.layers import Densefrom keras.layers import Flattenfrom keras.layers.embeddings import Embeddingfrom keras.preprocessing import sequence# fix random seed for reproducibilityseed = 7numpy.random.seed(seed)
Next we will load the IMDB dataset. We will simplify the dataset as discussed during the section on word embeddings. Only the top 5,000 words will be loaded.
We will also use a 50%/50% split of the dataset into training and test. This is a good standard split methodology.
Now we can create our model. We will use an Embedding layer as the input layer, setting the vocabulary to 5,000, the word vector size to 32 dimensions and the input_length to 500. The output of this first layer will be a 32500 sized matrix as discussed in the previous section.
We will flatten the Embedded layers output to one dimension, then use one dense hidden layer of 250 units with a rectifier activation function. The output layer has one neuron and will use a sigmoid activation to output values of 0 and 1 as predictions.
The model uses logarithmic loss and is optimized using the efficient ADAM optimization procedure.
# create the modelmodel = Sequential()model.add(Embedding(top_words, 32, input_length=max_words))model.add(Flatten())model.add(Dense(250, activation='relu'))model.add(Dense(1, activation='sigmoid'))model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])print(model.summary())
We can fit the model and use the test set as validation while training. This model overfits very quickly so we will use very few training epochs, in this case just 2.
There is a lot of data so we will use a batch size of 128. After the model is trained, we evaluate its accuracy on the test dataset.
# Fit the modelmodel.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=2, batch_size=128, verbose=2)# Final evaluation of the modelscores = model.evaluate(X_test, y_test, verbose=0)print("Accuracy: %.2f%%" % (scores[1]*100))
Running this example fits the model and summarizes the estimated performance. We can see that this very simple model achieves a score of nearly 86.94% which is in the neighborhood of the original paper, with very little effort.
Train on 25000 samples, validate on 25000 samplesEpoch 1/239s - loss: 0.5160 - acc: 0.7040 - val_loss: 0.2982 - val_acc: 0.8716Epoch 2/237s - loss: 0.1897 - acc: 0.9266 - val_loss: 0.3143 - val_acc: 0.8694Accuracy: 86.94%
Im sure we can do better if we trained this network, perhaps using a larger embedding and adding more hidden layers. Lets try a different network type.
Convolutional neural networks were designed to honor the spatial structure in image data whilst being robust to the position and orientation of learned objects in the scene.
This same principle can be used on sequences, such as the one-dimensional sequence of words in a movie review. The same properties that make the CNN model attractive for learning to recognize objects in images can help to learn structure in paragraphs of words, namely the techniques invariance to the specific position of features.
Keras supports one-dimensional convolutions and pooling by the Conv1D and MaxPooling1D classes respectively.
Again, lets import the classes and functions needed for this example and initialize our random number generator to a constant value so that we can easily reproduce results.
# CNN for the IMDB problemimport numpyfrom keras.datasets import imdbfrom keras.models import Sequentialfrom keras.layers import Densefrom keras.layers import Flattenfrom keras.layers.convolutional import Conv1Dfrom keras.layers.convolutional import MaxPooling1Dfrom keras.layers.embeddings import Embeddingfrom keras.preprocessing import sequence# fix random seed for reproducibilityseed = 7numpy.random.seed(seed)
# load the dataset but only keep the top n words, zero the resttop_words = 5000(X_train, y_train), (X_test, y_test) = imdb.load_data(num_words=top_words)# pad dataset to a maximum review length in wordsmax_words = 500X_train = sequence.pad_sequences(X_train, maxlen=max_words)X_test = sequence.pad_sequences(X_test, maxlen=max_words)
We can now define our convolutional neural network model. This time, after the Embedding input layer, we insert a Conv1D layer. This convolutional layer has 32 feature maps and reads embedded word representations 3 vector elements of the word embedding at a time.
The convolutional layer is followed by a 1D max pooling layer with a length and stride of 2 that halves the size of the feature maps from the convolutional layer. The rest of the network is the same as the neural network above.
# create the modelmodel = Sequential()model.add(Embedding(top_words, 32, input_length=max_words))model.add(Conv1D(filters=32, kernel_size=3, padding='same', activation='relu'))model.add(MaxPooling1D(pool_size=2))model.add(Flatten())model.add(Dense(250, activation='relu'))model.add(Dense(1, activation='sigmoid'))model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])print(model.summary())
# Fit the modelmodel.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=2, batch_size=128, verbose=2)# Final evaluation of the modelscores = model.evaluate(X_test, y_test, verbose=0)print("Accuracy: %.2f%%" % (scores[1]*100))
Running the example, we are first presented with a summary of the network structure. We can see our convolutional layer preserves the dimensionality of our Embedding input layer of 32-dimensional input with a maximum of 500 words. The pooling layer compresses this representation by halving it.
Running the example offers a small but welcome improvement over the neural network model above with an accuracy of nearly 87.79%.
Train on 25000 samples, validate on 25000 samplesEpoch 1/238s - loss: 0.4451 - acc: 0.7640 - val_loss: 0.3107 - val_acc: 0.8660Epoch 2/239s - loss: 0.2373 - acc: 0.9064 - val_loss: 0.2909 - val_acc: 0.8779Accuracy: 87.79%
Again, there is a lot of opportunity for further optimization, such as the use of deeper and/or larger convolutional layers. One interesting idea is to set the max pooling layer to use an input length of 500. This would compress each feature map to a single 32 length vector and may boost performance.
In this post, you discovered the IMDB sentiment analysis dataset for natural language processing.
You learned how to develop deep learning models for sentiment analysis including:
How to develop a large neural network model for sentiment analysis.
How to develop a one-dimensional convolutional neural network model for sentiment analysis.
Do you have any questions about sentiment analysis or this post? Ask your questions in the comments and I will do my best to answer.
Dr. Jason Brownlee is a husband, proud father, academic researcher, author, professional developer and a machine learning practitioner. He is dedicated to helping developers get started and get good at applied machine learning.
The test_split argument doesnt appear to exist in Keras 1.08, perhaps Im doing something wrong?
1. embeddings are trainable, right? I mean, embeddings are dynamic, and they are changing during the training?
2. How to save the embeddings to a file? We have to load the embeddings to predict new data in the future.
3. I have a file named predict.py. I know how to load the model and graph architecture from here: http://machinelearningmastery.com/save-load-keras-deep-learning-models/
But how to load embeddings in predict.py in order to predict new data?
An embedding is a projection, they can be prepared from data. I would not say they are learned, but perhaps you could say that.
I believe they can be prepared deterministically so we would not have to save them to file. I could be wrong about that, but that is my intuition.
Maybe I ask you a very stupid question, but I cant understand one thing. What is the Embedding layer? Could you show an example of it. I mean this is word vector with dimentionality of 500X32. So how it looks like? 
What digits in it? And why if we lift it dimensionality up to 64, the accuracy will rise up?
What params would you change typically to achieve what you have mentioned towards the end of the article to improve accuracy? 
To quote you: set the max pooling layer to use an input length of 500. This would compress each feature map to a single 32 length vector
Could you please help what params (which lines) would need this change?
I am testing the predicted probabilities and values using model.predict(X_test) and model.predict_classes(X_test)
I noticed that the predicted probabilities for the 0 class are all 0.5 w/ median predicted probability of 0.9673.
Am I correct in assuming the model.predict returns probability of the 1 class always, and predicts a class of 0 when that probability is < 50%?
I would expect that model.predict() is performing an arg max on the probabilities (selecting the class with the highest probability).
When an element in the data is labeled as an integer, lets say 4 for example, could that represent any word that has occurred 4 times in the data or is it a representation of a unique word?
My assumption is that we have mapped each word to its frequency in the whole corpus. If my assumption is true, so two words could come up with the same frequency. For example Dog and Cat both could repeat 10 times in the corpus. 
Hello Jason, recently i became acquainted with the basics in machine learning and deep learning, in part thanks to the information provided in this site, which I found most insightful.
However, lately I came upon a problem of generation simple and short questions automatically from a text. Due to my lack of knowledge and expertise i cant asses if it is possible to solve this problem with Deep Learning or any other method. Currently I have a database of several thousand questions based on around a hundred corpora that could be used as training data. Do you think I could get any successful results, and if so what approach will be the best? (Consider that even if it makes gibberish 50% of the time, it will still save a lot of work)
Id recommend reading some papers on the topic to spark some ideas on methods and ways to represent the problem.
Can you give me some idea on how to implement other Deep Learning techniqeus such as recursive autoencoders(RAE) , RBM deep learning algorithm for sentiment analysis
Hello, thanks for the example. I really appreciate you if you suggest me why I got this error.
MissingGXX: (The following error happened while compiling the node, Shape_i{1}(embedding_2_W), \n, g++ not available! We cant compile c code., [Shape_i{1}(embedding_2_W)])
@Zhang, looks like you have a beta version of Theano. If youre just looking to get started, maybe you want to try a stable channel instead? Looks like your error is because youre installing from source and your environment isnt set up quite right.
@Jason, thanks for your reply and thanks again for the post!
I am having trouble improving the results on this model. I have changed the pool_length (500,250,125,375,5,10,15,20), tried adding another dense layer at size 250 and 500, and changed the number of epochs (25,50). 
Do you have any recommendations for tweaking the model? I tried the suggestions (deeper, larger, pool_length, and also number of epochs). Do you have any tips or reading suggestions for improving performance in general? This seems to be my last wall to really being able to do ML.
Perhaps changes to the structure of the problem itself are required.
This post might shake loose more ideas on how to improve performance:
Hi jason, I removed the denser layer with 250 neurons and it reduced the number of parameters to be trained drastically with an increased accuracy of about 1% over 5 epochs. Any idea why you added 2 dense layers after flatten layer?
Does it make sense to specify validation_data as X_test,y_test in the fit function if we evaluate our model in the scores function afterwards? Or could we skip specify validation_data in model.fit()?
Hi, Jason, i have the same question with Maxim. Can you tell me why is that.Thank you
Maybe I ask you a very stupid question, but I can’t understand one thing. What is the Embedding layer? Could you show an example of it. I mean this is word vector with dimentionality of 500X32. So how it looks like?
What digits in it? And why if we lift it dimensionality up to 64, the accuracy will rise up?
However , Im Asking About How To Use This To Predict The Opinion
I Still Dont know , for instance i need to know the movie is good or bad , or if i used a twitter data set i need to know the public opinion summary about a specific hashtag or topic
I tried More And More But i Failed as im still Beginner 
I have a question here. I didnt understand why we use ReLU instead of tanh as the activation function. Most people use SGD or backpropagation for training. What did we use here? I do not know about ADAM. Can you please explain why did you use it for training?
Hi, thanks a lot for this HELPFUL tutorial. I have a question, could be an odd one. what if we use pre-trained word2vec model. I mean if we just use pre-trained word2vec model and train our neural network with movie reviews data. Correct me if I am wrong!
Or best way is to train word2vec with movie reviews data, then train neural network with same movie reviews data then try.
I am trying to use tfidf matrix as input to my cnn for document classification. I dont want to use embedding layer. Can you help me how this can be achieved. I have not seen any example which shows tfidf as input to Cov1d layer in Keras. Please help
